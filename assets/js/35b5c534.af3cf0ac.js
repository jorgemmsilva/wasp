(self.webpackChunkdoc_ops=self.webpackChunkdoc_ops||[]).push([[5155],{1881:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return l},default:function(){return m}});var a=n(2122),r=n(9756),i=(n(7294),n(3905)),o=["components"],c={},s="Core types",p={unversionedId:"misc/coretypes",id:"misc/coretypes",isDocsHomePage:!1,title:"Core types",description:"All core types used in the Wasp code are defined in the",source:"@site/docs/misc/coretypes.md",sourceDirName:"misc",slug:"/misc/coretypes",permalink:"/docs/misc/coretypes",editUrl:"https://github.com/iotaledger/chronicle.rs/tree/main/docs/docs/misc/coretypes.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"UTXO Ledger and Digital Assets",permalink:"/docs/misc/utxo"},next:{title:"On-chain accounts",permalink:"/docs/misc/accounts"}},l=[{value:"Chain ID",id:"chain-id",children:[]},{value:"Hashed names",id:"hashed-names",children:[]},{value:"Smart contract ID",id:"smart-contract-id",children:[]},{value:"Agent ID",id:"agent-id",children:[]},{value:"Colored balances",id:"colored-balances",children:[]}],d={toc:l};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"core-types"},"Core types"),(0,i.kt)("p",null,"All core types used in the Wasp code are defined in the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/wasp/tree/master/packages/iscp"},(0,i.kt)("inlineCode",{parentName:"a"},"iscp")),"\npackage."),(0,i.kt)("h2",{id:"chain-id"},"Chain ID"),(0,i.kt)("p",null,"ISCP allows running multiple blockchains, called ",(0,i.kt)("em",{parentName:"p"},"smart contract chains"),", ",(0,i.kt)("em",{parentName:"p"},"contract chains")," or just\n",(0,i.kt)("em",{parentName:"p"},"chains")," on the Tangle in parallel."),(0,i.kt)("p",null,"A chain is defined by two properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"chain ",(0,i.kt)("em",{parentName:"li"},"address")," (type ",(0,i.kt)("inlineCode",{parentName:"li"},"address.Address")," from GoShimmer, 33 bytes long)"),(0,i.kt)("li",{parentName:"ul"},"chain ",(0,i.kt)("em",{parentName:"li"},"color")," (type ",(0,i.kt)("inlineCode",{parentName:"li"},"balance.Color")," from GoShimmer, 32 bytes long)")),(0,i.kt)("p",null,"Both address and color uniquely identify a chain. However, the chain address is\ntransient because chains can be moved from address to address. The chain color\nis an ultimate identifier of the chain for its lifetime."),(0,i.kt)("p",null,"Each chain is identified on the ISCP by its ",(0,i.kt)("em",{parentName:"p"},"chain ID"),", represented by the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/wasp/blob/master/packages/iscp/chainid/chainid.go"},(0,i.kt)("inlineCode",{parentName:"a"},"iscp.ChainID")),"\ntype. In the current implementation ",(0,i.kt)("inlineCode",{parentName:"p"},"iscp.ChainID")," is just a synonym of\nthe chain address. In the future, the chain color will be used as chain ID."),(0,i.kt)("h2",{id:"hashed-names"},"Hashed names"),(0,i.kt)("p",null,"The hashed values of string identifiers (called ",(0,i.kt)("em",{parentName:"p"},"hname")," for short) are used in\nseveral places of the sandbox interface as type ",(0,i.kt)("inlineCode",{parentName:"p"},"iscp.Hame"),".  The type is\nalias of ",(0,i.kt)("inlineCode",{parentName:"p"},"uint32"),"."),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"iscp.Hn(string) iscp.Hname")," is used to compute the\nhname of an identifier, by hashing the string with ",(0,i.kt)("inlineCode",{parentName:"p"},"blake2b")," and returning the\nfirst 4 bytes, cast to uint32 (little endian). (If all 4 bytes are ",(0,i.kt)("em",{parentName:"p"},"0x00")," or\n",(0,i.kt)("em",{parentName:"p"},"0xFF"),", the function takes the next 4 bytes, since ",(0,i.kt)("inlineCode",{parentName:"p"},"0x00000000")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"0xFFFFFFFF")," are reserved values.)"),(0,i.kt)("h2",{id:"smart-contract-id"},"Smart contract ID"),(0,i.kt)("p",null,"Each chain hosts multiple smart contracts. Each smart contract instance has a\n",(0,i.kt)("em",{parentName:"p"},"name"),", a string value, assigned by the chain owner at deployment time.  The\n",(0,i.kt)("em",{parentName:"p"},"hname")," of the ",(0,i.kt)("em",{parentName:"p"},"name")," uniquely identifies the contract within a particular\nchain."),(0,i.kt)("p",null,"The global identifier of the smart contract is represented by the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"iscp.ContractID"),".  The ",(0,i.kt)("em",{parentName:"p"},"contract ID")," is concatenation of the ",(0,i.kt)("em",{parentName:"p"},"chain ID"),"\nand ",(0,i.kt)("em",{parentName:"p"},"hname")," of the contract (resulting in a 37 byte long value):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<contract ID> = <chain ID> || <contract hname>\n")),(0,i.kt)("p",null,"The user-friendly representation of the contract ID is ",(0,i.kt)("inlineCode",{parentName:"p"},"<chain ID (base58)>::<hname (hex)>"),".\nFor example: ",(0,i.kt)("inlineCode",{parentName:"p"},"2AxoLpidnriXtSif5NnXSWdt28fUb6VwVRjULdDoe6pZVw::cebf5908"),"."),(0,i.kt)("h2",{id:"agent-id"},"Agent ID"),(0,i.kt)("p",null,"In the IOTA Tangle, iotas and colored tokens are owned by an address. Only the\nentity owning the corresponding private key is able to spend from the address."),(0,i.kt)("p",null,"In ISCP, iotas and colored tokens can be owned either by an address or by a\nsmart contract. In the latter case, only the contract represented by the\ncontract ID can spend those tokens, i.e. only the contract program can move\nthem to another location."),(0,i.kt)("p",null,"In order for contracts to be able to manipulate tokens, the tokens have to be\ntransferred to the chain address. The chain keeps a ledger to know who is the\nactual owner of the tokens (address or contract), and allows the actual owner\nto withdraw at any time (more on this ",(0,i.kt)("a",{parentName:"p",href:"/docs/misc/accounts"},"here"),")."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"agent ID")," (",(0,i.kt)("inlineCode",{parentName:"p"},"iscp.AgentID")," type, 37 bytes) represents an owner of\ntokens in the internal chain ledger. It is a union type that can be either an\nIOTA address (when the last 4 bytes are 0x00) or an ISCP contract ID."),(0,i.kt)("p",null,"User-friendly representations of both types of ",(0,i.kt)("em",{parentName:"p"},"agent ID")," are prefixed by ",(0,i.kt)("inlineCode",{parentName:"p"},"A/"),"\n(for addresses) and ",(0,i.kt)("inlineCode",{parentName:"p"},"C/")," (for contracts), like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"A/26yEvt3imFtcvK4NpgXK3499Rw2man3LTuvK2Mg4Rp8reZ\nC/mZdSYhXd4F5qQGgELK8JvzUYovcNmPoVHxW1p4LF4gxT::cebf5908\n")),(0,i.kt)("h2",{id:"colored-balances"},"Colored balances"),(0,i.kt)("p",null,"The interface ",(0,i.kt)("inlineCode",{parentName:"p"},"iscp.ColoredBalances")," represents a map of color values and\ntheir balances. The implementation is backed by the type ",(0,i.kt)("inlineCode",{parentName:"p"},"map[balance.Color]int64"),".\nIt is guaranteed that the map does not contain colors with balance 0."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"IOTA: 100000\nmZdSYhXd4F5qQGgELK8JvzUYovcNmPoVHxW1p4LF4gxT: 1\n")))}m.isMDXComponent=!0},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=p(n),h=r,u=m["".concat(s,".").concat(h)]||m[h]||d[h]||i;return n?a.createElement(u,o(o({ref:t},l),{},{components:n})):a.createElement(u,o({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);